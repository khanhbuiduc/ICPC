Bit manipulation
---------------------------------------------------

H. Maximal AND
Tìm giá trị lớn nhất có thể của phép AND toàn bộ mảng sau khi thực hiện tối đa k phép toán.

Phép toán cho phép
    Chọn chỉ số i (1 ≤ i ≤ n)
    Thay a[i] bằng a[i] OR 2^j với j từ 0 đến 30
        - Tức là bật bit thứ j của a[i] lên 1
Output
    Giá trị lớn nhất của a[1] & a[2] & ... & a[n]
---
thuat toan chuan
Duyệt từ bit cao nhất (30) xuống bit thấp nhất (0)
    Với mỗi bit j:
        Đếm số phần tử chưa có bit j bật
        Nếu có thể bật tất cả bit j với số phép toán còn lại:
            Thực hiện bật và trừ số phép toán
        Kết quả sẽ có bit j = 1
        Tiếp tục với bit tiếp theo

---
B. Rock and Lever

Đếm số cặp (i,j) với i < j sao cho a[i] & a[j] >= a[i] ⊕ a[j]

Output
Số lượng cặp thỏa mãn điều kiện
---
tu phan tich:
    1&1 >= 1^1 true
    1&0 >= 1^0
    0&0 >= 0^0 true 
    0&1 >= 0^1
=> neu bit dau tien cua a&b dong thoi la 1 thi thoa man.
----------------------
trong đáp án:

check[i] = true nếu số thứ i đã đc sử dụng, ngược lại là false

duyệt bit: 30->0
    //đếm xem: có bao nhiêu bít i = 1 và chưa đc sử dụng
    cnt = 0;
    nếu !check[i] và a[i]&(1<<bit) > 0
        cnt++;
    ans+= cnt*(cnt-1)/2
------------------------
khánh:
cnt[i]: đếm xem có bao nhiêu số có bít lớn nhất bằng i;  
duyệt i: 1->n;
    for bit:30->1:
        nếu a[i]&&(1<<bit) thì cnt++;
FOR i:0->30
    ans += C(cnt[i],2)

---------------------------------------------------
Maximum XOR Subarray

Tìm giá trị XOR lớn nhất của một subarray (dãy con liên tiếp) trong mảng.

cach cua claude: Prefix XOR + Trie:

Tính Prefix XOR:
    prefix[i] = a[0] ⊕ a[1] ⊕ ... ⊕ a[i]
    ket qua: max (prefix[j] ⊕ prefix[i])

Cấu trúc Trie cho bit:
    Lưu trữ các prefix XOR dưới dạng nhị phân
    Mỗi node có tối đa 2 con (bit 0 và bit 1)

Thuật toán:

    Với mỗi prefix XOR hiện tại
    Tìm trong Trie prefix XOR trước đó sao cho XOR với nó cho kết quả lớn nhất
    Ưu tiên chọn bit khác nhau ở các vị trí cao

Tối ưu hóa:
    Duyệt từ bit cao nhất xuống bit thấp nhất
    Chọn đường đi cho XOR lớn nhất

---

---------------------------------------------------

F. Equal XOR Segments

Mục tiêu: Kiểm tra xem a[l..r] có thể chia thành k > 1 phần sao cho XOR của mỗi phần đều bằng nhau.

a=[1,1,2,3,0] voi q(1,5)-> Yes
vì 1=1=2^3^0
---
nhan xet:

neu chia thanh k phan bang nhau:
    res = y1 ^ y2 ... ^ yk
    - neu k chan: res = y1.
    - neu k le: res = 0.
---
neu: xor = 0 => yes.
neu: xor = y1 => ton tai subarr_xor = y1 => yes 

-------------------------------------------------------
take A Guess
Đây là bài interactive: Cần tìm phần tử thứ k nhỏ nhất trong mảng ẩn bằng cách hỏi tối đa 2⋅n câu hỏi.

Input:

n phần tử trong mảng (3 ≤ n ≤ 10⁴)
k: cần tìm phần tử thứ k nhỏ nhất (1 ≤ k ≤ n)
Các loại câu hỏi có thể hỏi:

"or i j": Hỏi kết quả a[i] | a[j] (bitwise OR)
"and i j": Hỏi kết quả a[i] & a[j] (bitwise AND)
"finish res": Trả lời kết quả cuối cùng

---
nhan xet: a + b = a | b + (a & b)

thuat toan chuan:
    a[1] & a[2] = x12;
    a[1] | a[2] = y12;
    tuong tu voi (a[2], a[3]) va (a[3], a[4]);

a[1] + a[2] = x12 + y12; (*)
a[2] + a[3] = x23 + y23; (**)
a[1] + a[3] = x13 + y13; (***)

=> (*) + (***) - (**)
<=> 2*a[1] = (x12 + y12) +  (x13 + y13) - x23 + y23
=> tinh dc a[1], a[2], a[3];
---

tinh a[4..n]:
a + b = a | b + (a & b)
=> a = a | b + (a & b) - b;
=> a[i] = a[1] | a[i] + a[1] & a[i] - a[1]

--> in ra nth_elementth(a, a + k -1, a+end)


