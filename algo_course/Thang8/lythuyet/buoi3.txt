SQUARE ROOT DECOMPOSITION

B. The BOSS Can Count Pairs

Đề bài:
Cho mảng a[1..n], b[1..n]
Đếm số cặp (i,j) sao cho 1≤i<j≤n và ai * aj = bi + bj

Cách ngây thơ:
for mọi cặp (i,j) với i < j:
    if ai * aj = bi + bj:
        cnt++
Độ phức tạp: O(n²) - quá chậm

---

nhan xet: 
    bi + bj <= 2n 
    => ai * aj <= 2n
    => min(ai, aj) ≤ √(2n)

do phuc tap: O(n * √(2n)) < 100'000 * 500
---

THUẬT TOÁN:

1. Nhóm phần tử theo giá trị a[i]:
   groups[val] = vector<pair<bi, index>>

2. Duyệt các cặp giá trị (ai, aj):
   for ai in groups:
       if val1 * val1 > 2*n: break  // Tối ưu
       
       for aj in groups:
           if ai * aj > 2*n: break
           
           // Điều kiện: ai * aj = bi + bj

3. Đếm cặp chi tiết:
   Với mỗi cặp (val1, val2):
   - Duyệt list1 = groups[val1]
   - Duyệt list2 = groups[val2] 
   - Đếm cặp (i,j) với i < j và bi + bj = val1 * val2

4. Tối ưu cho trường hợp val1 = val2:
   - Cần xử lý riêng để tránh đếm trùng
   - Sử dụng map để đếm nhanh hơn

------------------
DQUERY

Với mỗi truy vấn (i, j), đếm số phần tử phân biệt trong đoạn a[i], a[i+1], ..., a[j]

-----
nhan xet:
Sử dụng Mo's Algorithm (Square Root Decomposition):

1. Chia các truy vấn thành √n nhóm theo giá trị i/√n
2. Sắp xếp truy vấn: trong cùng nhóm, sắp xếp theo j
3. Duy trì cửa sổ trượt [L, R] và đếm phần tử phân biệt:
   - Dùng mảng cnt[] để đếm tần suất
   - Dùng biến distinct để đếm số phần tử phân biệt
4. Mở rộng/thu hẹp cửa sổ để xử lý từng truy vấn

Ví dụ cụ thể:
Mảng: a = [1, 1, 2, 1, 3] (n = 5)
Truy vấn: (1,5), (2,4), (3,5), (1,3), (2,5)

Bước 1: Chia truy vấn thành √n nhóm
   √5 ≈ 2.24 → chọn block_size = 2
   Nhóm 0: i/2 = 0 → truy vấn có i ∈ [1,2]
   Nhóm 1: i/2 = 1 → truy vấn có i ∈ [3,4]
   Bước 2: Sắp xếp truy vấn
Bước 2: Sắp xếp truy vấn
   Truy vấn gốc: (1,5), (2,4), (3,5), (1,3), (2,5)

   Nhóm 0 (i ∈ [1,2]): (1,5), (2,4), (1,3), (2,5)
   - Sắp xếp theo j: (1,3),(2,4), (1,5), , (2,5)

   Nhóm 1 (i ∈ [3,4]): (3,5)
   - Đã sắp xếp: (3,5)

   Thứ tự xử lý: (1,3),(2,4), (1,5), (2,5), (3,5)