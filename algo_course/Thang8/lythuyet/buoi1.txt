
------------------------------------------------------------------------------------
FINDBRACSEQ

Mục tiêu: Tìm dãy con dài nhất của xâu S sao cho dãy con đó là dãy ngoặc đúng.

Input: Xâu S độ dài n chứa các ký tự '(' và ')'

Output: Độ dài của dãy con dài nhất là dãy ngoặc đúng

Ý tưởng chính:

    - Sử dụng stack hoặc biến đếm để theo dõi số ngoặc mở/đóng hợp lệ
    - Duyệt từ trái sang phải, ghép cặp ngoặc mở với ngoặc đóng
    - Đếm số cặp ngoặc hợp lệ được tạo thành

merge sort:
    Cấu trúc Node:
        - open: Số ngoặc mở '(' chưa được ghép
        - close: Số ngoặc đóng ')' chưa được ghép
        - pairs: Số cặp ngoặc đã ghép thành công

    Base case:
        - Gặp '(' → Node(1, 0, 0)
        - Gặp ')' → Node(0, 1, 0)
        - Ký tự khác → Node(0, 0, 0)

    Merge hai nửa:
        - Tính số cặp có thể ghép: canPair = min(leftNode.open, rightNode.close)
        - Cập nhật số ngoặc dư: trừ đi số đã ghép
        - Cộng thêm số cặp mới ghép được

-----------------------------------------------------

C11SEQ
Đề bài: Cho mảng a[1..n] và hai số L, R. Đếm số cặp (i,j) sao cho L ≤ sum(a[i..j]) ≤ R

Input:
    Dòng 1: n, L, R
    Dòng 2: mảng a[1..n]
Output: 
    Số lượng dãy con liên tiếp có tổng trong khoảng [L, R]

Ý tưởng chính: merge sort

1. Base case: Nếu l == r
    kiểm tra xem a[l] có trong khoảng [minSum, maxSum] không

2. Chia nhỏ: 
    Chia đoạn [l, r] thành 2 phần [l, mid] và [mid+1, r]

3. Đếm cross pairs: 
    - Tính tất cả prefix sum từ mid về trái (preLeft)
    - Tính tất cả suffix sum từ mid+1 về phải (sufRight)
    - Với mỗi rightSum, tìm số leftSum sao cho minSum ≤ leftSum + rightSum ≤ maxSum
        - Sử dụng binary search để đếm hiệu quả

4. Kết hợp: Tổng = leftCnt + rightCnt + crossCnt

----------------------------------------------------------
Maximum Subarray

Đề bài: Cho mảng số nguyên, tìm:

Maximum Subarray Sum: Tổng lớn nhất của dãy con liên tiếp
Maximum Subsequence Sum: Tổng lớn nhất của dãy con bất kỳ (không cần liên tiếp)
-----
Maximum Subsequence:
    Nếu có số dương: tổng tất cả số dương
    Nếu toàn số âm: chọn số lớn nhất

-----Maximum Subarray Sum
Ý tưởng chính: merge sort

node:
    maxSum: Tổng subarray lớn nhất trong đoạn
    maxLeft: Tổng lớn nhất bắt đầu từ điểm trái nhất
    maxRight: Tổng lớn nhất kết thúc ở điểm phải nhất
    totalSum: Tổng toàn bộ đoạn
Base case: 
    Đoạn có 1 phần tử
Merge: 
    Kết hợp 2 nửa, tính toán các giá trị mới
    Cross middle: leftResult.maxRight + rightResult.maxLeft
    maxSum = max(Cross middle, left.maxSum, right.maxSum)

----------------------------------------
Merge Sort tree.

Đếm số lượng inversions trong một mảng bằng cách sử dụng thuật toán Merge Sort.

Định nghĩa Inversion:

Một inversion là một cặp chỉ số (i, j) sao cho i < j nhưng arr[i] > arr[j]
Nói cách khác, hai phần tử không theo thứ tự tăng dần

y tuong: MergeSort(L,R) = left.cnt + right.cnt + more:
node:
    cnt: so luong inversions
    arr[l,r]: duoc sort.

Base case: Đoạn có 1 phần tử → cnt = 0, sorted = {arr[i]}

Tính Cross Inversions(more):
    Với mỗi phần tử x trong rightNode.sorted:
    - Đếm số phần tử trong leftNode.sorted lớn hơn x
    - Sử dụng lower_bound để tìm vị trí đầu tiên >= x
    - Số inversions = leftNode.sorted.size() - (lower_bound_position)


--------------------------------------------------------
max to the right to min

cho một hoán vị p[1..n]
đếm số cặp (i,j) sao cho vị trí số lớn nhất > vị trí số nhỏ nhất.

solve(l,r): đếm số cặp (i,j) thỏa mãn 1<=i<=j<=r   
pos(min) < pos(max)

solve(l,r) = solve(l,mid) + solve(mid +1,r) + more;

th1: max min bên trái:
    sufmax[i], sufmin[i]

lưu trữ: pos[[p[i]]] = i