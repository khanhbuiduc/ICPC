Angry Birds:

1 chú chím khi bay với thời điểm là t thì độ cao của chú chim sẽ là f(t). Trong đó f(t) là hàm có dạng f(t) = a + b.t + c.t^2

Hòi chú chim sẽ bay theo đường cong úp ngược hay đường cong quay lên hay sẽ bay theo đường thang ?????

------------------
Ta có: f(t) = a + b.t + c.t^2 là phương trình của 1 đường parabol

Tình huống 1: Nếu c - 0, f(t) - a + b.t -- > phương trình đường thang (xuất ra thông báo là đường thang)

Tình huống 2: Nếu c > 0, f(t) = a + b.t + c.t^2 là phương trình đường parabol có điểm cực tiểu

Tình huôgns 3: Nếu c < 0, f(t) = a + b.t + c.t^2 là phương trình đuong parabol up ngược.

---------------------------------------------------------------------------------
Greatest Common Divisors:

Cho một dãy số nguyên a gồm N số. Xét mọi tập hợp các số trong dãy a và ta tính ước chung lớn nhat của cac so nay. Hoi tổng của tat ca cac ước chung lớn nhat của tat

cả các tập hợp trong dãy a là bao nhiêu ?????????
---
1 10 5 7 2
1<= a[i] <=7
1 số: 1 10 5 7 2
2 số:{1,10} {1,5} {1,7} {1,2} {10,5} {10,7} {10,2}
3 số: {1, 10, 5} {1,10,7} {1,10,2} ...


gọi f[i][g]: là số cách chọn
    - xét i số
    - UCLN = g
btcs f[0][0] = 1;

đáp án bài toán:

    tổng g * f[n][g] với g: 1->70

QHD:
    f[i][g] > 0;
    ta không chọn số ở vị trí i+1
        f[i+1][g] += f[i][g]
    ta chọn số ở vị trí i+1:
        g=0: f[i+1][a[i+1]] += f[i][g]
        g>0: f[i+1][gcd[g,a[i+1]]] += f[i][g]
--------------------------------

Dazzing:

Cho một dãy số nguyên a gồm N số, các số a[i] năm trong đoạn [1 .. n]. Hòi có bao nhiêu đoạn [1 .. r] sao cho các số trong đoạn [1 .. r] hoàn toàn khác nhau.

Nhận xét:

a = [5, 2, 9, 1, 1, 2, 6]

Nếu 1 đoạn [1 .. r] có các số khác nhau thì tat ca cac đoạn con trong đoạn nay deu se chua cac so khac nhau.

i -1-> 1=1
i - 2 -> 1=1
i - 3 ->1=1
i - 4 ->1=1
i=5->1=5
1=6->1=5
1 -7->1=5

====== > đây là hình ảnh của 2 pointers

1 đoạn [l .. i] sẽ thỏa mãn khi: số lượng số khác nhau = i - l + 1
Gọi mảng count[x] với ý nghĩa: count[x] là số lượng số có gia trị x TÍNH ĐEN THỜI ĐIỂM HIỆN TẠI
Gọi numDiff là số lượng số khác nhau.

Khi ta co a[i], count[a[i]]++, neu count[a[i]] == 1: numDiff++

while numDiff < i - 1 +1:
count[a[1]] --
neu count[a[1]] -- 0:
numDiff --
1++

---- > cộng i - 1 + 1 vào ans

-------------------------------------------------


Lcs2x

Cho 2 dãy số a và b, dãy a co N số và dãy b co M số. Hãy tìm c là dãy con chung dai nhat của dãy a và b, với 1 điều kiện:

2 * c[i] <= c[i +1]

Thuật toán ngây thơ:

Gọi f[1][j] là độ dài của dãy con chung dài nhất khi ta chấp nhận a[i] va b[j] làm phan từ chung của day c (a[i] - b[j])
công thức:

f[i][j]= max(f[x][y] +1) với x < i, y < j và a[x] == b[y] và 2 * a[x] <- a[i]

Độ phức tạp: 0(N^2 * M^2)
------------------------
thuật toán chuẩn.
Xem xét bài toán:

a - [0, 9, 1, 2, 6, 3, 8]

a - [0, 9, 1, 2]
b - [0, 1, 6, 2, 4, 8]
f[1][j] = [0, -1, -1, -1, -1, -1]
f[2][j] - [0, 1, -1, -1, -1, -1]
f[3][j] - [e, -1,
---------------------------------------------
Gọi f[i][j] là độ dài dãy con chung dài nhất khi có i phần tử đầu tiên của day a và phan tử cuoi cùng trong day chung la b[j]
bài toán cơ sở: f[0][0] -0, f[0][j] - -1
đáp ẩn bài toán: Max(f[n][j])

-----------------

công thức qhđ:

f[i][j] = f[i - 1][j]
neu a[i] == b[j]:
    f[i][j] - max(f[i - 1][y] + 1) voi y < j va 2 * b[y] <- b[j]

maxLength = 0
Duyệt j: 0 -> m
    nếu b[j] == a[i]:
        f[i][j] = max(f[i][j], maxLength + 1)
    nếu 2 * b[j] <= a[i]
        maxLength = max(maxLength, f[i - 1][j])

for i: 1 -> n
    maxLength = -2
    Duyệt j: 0 -> m
        f[i][j] - f[i - 1][j]
        neu b[j] == a[i]
            f[i][j] - max(f[i][j], maxLength + 1)
        nếu 2 * b[j] <- a[i]:
            maxLength = max(maxLength, f[i - 1][j])