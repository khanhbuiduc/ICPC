AC4 (Autumn Contest 2020)

Cho một bản nhạc gồm N not (Do - Re - Mi - Fa - Sol - La - Si). Một đoạn gọi cao trào nếu đoạn đó gồm 3 nốt nhạc liên tục, trong đó nốt ở giữa có cao độ cao hơn hẳn

2 nốt còn lại hoặc nốt ở giữa có cao độ thấp hơn hần 2 nốt còn lại.

Một bản nhạc được gọi là hay nếu có tối thiểu M đoạn cao trào. Hỏi bản nhạc này có hay hay không ?????

Mã hóa các nốt nhạc sang số: Do - 0, Re - 1p ..... , Si - 6
Xét 3 nốt i, i + 1 và i + 2, 3 nốt này tạo thành 1 đoạn cao trào nếu a[i + 1] > a[i] và a[i + 1] > a[i + 2] hoặc a[i + 1] < a[i] và a[i + 1] < a[i + 2]
Ta đếm có bao nhieu đoạn cao trao va so sanh với M

---
Video Cards:

Cho một day so nguyen duong a gom N so a[1], a[2], .... , a[N]
Ta chọn một số a[i] nào đó và với các số a[j] còn lại, ta sẽ đưa số đó đến bội gần nhất của a[i] mà <- số đó.
Sau khi biến đổi, ta tính tổng của tất cả các số trong dãy.

Hòi tổng lớn nhat có thể đạt được là bao nhiêu ?????

N = 6

a = [5, 2, 1, 9, 4, 6]
x=2

[4, 2, 0, 8, 4, 6] =24

x-3

[3, 0, 0, 9,3, 6]

Ví dụ:

a = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
x - 10

Nhận xét: 1 <= a[i] <= 200000

Ta tạo count với ý nghĩa count[i] la so lượng so co gia trị <- i

count[0] = 0
count[1] = 1
count[2] - 2
count[3] = 0
count[4] = 1
count[5] =1
count[6] = 1
count[7] = 0
count[8] = 0
count[9] - 1

Duyệt[ i: 1 -> 200000 ]
count[i] += count[i - 1]

x= 2
    sum = 0
    j = 2, số lượng số có thể quy về được j = 2: count[j + x - 1] - count[j - 1] ==== > sum = sum + j * (count[j + x - 1] - count[j - 1])
    j = 4,
    j - 6, .

j = 200000
////////////

for x: 1 -> 200000
    sum = 0
    for j = x, j <= 200000, j = j + x
        sum = sum + j * (count[j + x - 1] - count[j - 1])
        ans = max(ans, sum)

O(N+N/2+...N/200000) = O(nln(n))

Sang nguyên to Erathoneses

Tạo một bảng isPrime[i] với ý nghĩa: isPrime[i] = true: i là số nguyên tố, isPrime[i] = false, i không phải.

Khoi tạo isPrime[i] = true, ngoai trừ isPrime[1] = false

Duyệt i: 2 -> 1000000
nếu isPrime[i] == true
for j = 2 * i; j <= 1000000; j += i
isPrime[j] = false
------------------------------------------------------

Good key and Bad key

Cho N rương, rương thứ i có số đồng xu là a[i]. Ta có 2 loại chìa khóa, một loại là "good key" và loại còn lại là "bad key"

Ta phải mở rương lần lượt từ rương 1 -> rương N.

Nếu như ta sử dung "good key" ta sẽ mat một lượng dồng xu la C

Nếu như ta sử dụng bad key để mở rương i, tất cả các rương j (j: i -> N), mỗi rương sẽ bị giảm số đồng xu một nửa và ta không mất xu

Hỏi: Số đồng xu tõi đa ta có thể thu được là bao nhiêu ???????

1 5 2 5 2 1 6 3

Nhận xét: Do a[i] <= 1000000000 ----- > sau tối đa 30 lần chia đôi thì a[i] sẽ trở về thành số 0

Gọi f[i][j] là tổng lượng đồng xu lớn nhất khi ta có i rương đầu tiên và ta đã sử dụng j bad key
bài toán cơ sở: f[0][0] - 0, khởi tạo cac f[i][j] - -1

đáp án bài toán: Max(f[n][j]) với j: 0 ---- > 30

Khi ta có f[i][j] != -1

Xét rương i + 1

. Nếu rương i + 1 dùng good key: f[i + 1][j] = max(f[i + 1][j], f[i][j] +(a[i+1] / power2[j]) - C) (power2[i] = 2^i)
. Nếu rương i + 1 dùng bad key (j < 30): f[i + 1][j + 1] = max(f[i + 1][j+ 1], f[i][j] + a[i+1] / power2[j + 1])

====> lỗi: khi sử dụng 30 key rồi thì những rương sau không có badkey nữa mà chỉ sử dụng good key 

update:
Xét rương i + 1

. Nếu rương i + 1 dùng good key: f[i + 1][j] = max(f[i + 1][j], f[i][j] +(a[i+1] / power2[j]) - C) (power2[i] = 2^i)
. Nếu rương i + 1 dùng bad key : f[i + 1][(min(j + 1),30)] = max(f[i + 1][(min(j + 1),30)], f[i][j] + a[i+1] / power2[j + 1])

--------------------------------------------------------------
Divisor Analysis

Cho N cặp p[i], x[i] với ý nghĩa: Trong cách phân tích thừa số nguyên tố của số N nào đó, có sự tồn tại của p[i]^x[i] (p[i] là số nguyên tố)

Hãy xuat ra so lượng uớc so cua so N, tổng cac uoc so cua so N va tich cac uớc so của so N

Vì kết quả rất lớn, hãy xuất ra kết quả sau khi modulo cho 1000000007

Ví dụ:

3
2 3
3 1
71

N = 2^3 * 3^1 * 7^1 = 168

168 có các ước: 1, 2, 3, 4, 6, 7, 8, 12, 168, 84, 56, 42, 28, 24, 21, 14 : 16 ước

N = 168 = 2^3 * 3^1 * 7^1

42 = 2^1 * 3^1 * 7^1

168 / 42 = (2^3 * 3^1 * 7^1) / (2^1 * 3^1 * 7^1)

---
Tính tổng các ước:

x= p[1]^y[1] *p[2]^y[2] *..... * p[k]^y[k]
(A + B) * (A + B)
(A + B + C) * (D + E + F) = A * D + A * E + A * F + B * D + B * E + B * F + C * D + C * E + C * F
(A + B) * (D + E) * (F + G) - A * D * F + A * D * G + A * E * F + A * E * G + . .....

N = 168 - 2^3 * 3^1 * 7^1
==== > Tổng các ước = (p[1]^0 + p[1]^1+ p[1]^2+ .... +p[1]^x[1]) * (p[2]^0+p[2]^1+ .... +p[2]^x[2]) * .... * (p[k]^0 + p[k]^1+ .... + p[k]^x[k])
S = 1 + x + x^2 + ..... + x^n           (1)
x.S = x + x^2 + x^3 + .... + x^(n + 1)  (2)

(2) - (1)

(x - 1).S = x^(n +1) - 1

<= > S = [x^(n+1) - 1] / (x+1)

--------------
Tính tích các ước:

x= p[1]^y[1]*p[2]^y[2] * .....* p[k]^y[k]

Ta thấy:

Xét riêng p[1], sõ lần xuất hiện của p[1]^0, p[1]^1, .... , p[1]^x[1] là như nhau và cùng bằng (x2 + 1) * (x3 + 1) * ..... * (xk +1)
Xét riêng p[2], số lần xuất hiện của p[2]^0, p[2]^1, .... , p[2]^x[2] là như nhau và cùng bằng (x1 + 1) * (x3 + 1) * ..... * (xk +1)

Xét riêng p[k], số lần xuất hiện của p[k]^0, p[k]^1, .... , p[k]^x[k] là như nhau và cùng bằng (x1 + 1) * (x2 + 1) * ..... * (xk-1 + 1)

Xét p[1], số lũy thừa của p[1] = (0+1+2+3+ .... +x[1]) * (x2 +1) * (x3 + 1) * ..... * (xk + 1)

Xét p[2], số lũy thừa của p[2] =(0+1+2+3+ .... +x[2]) * (x1+1) * (x3 +1) *..... * (xk + 1)

Xét bài toán: Tính x^N % M (với M là số nguyên tố) và N cực kỳ lớn
-----------
Định lý fermat nhỏ:

Với M là số nguyên tố, với mọi số a (không chia hết cho M) thì a^(M - 1) % M = 1

x^N % M

Ta tách số N thành N = d * (M - 1) + r

x^N = x^ (d * (M - 1) + r) = x^(d * (M - 1)) * x^r = (x^(M - 1))^d * x^r % M = x^r % M

N %(MOD-1) = R;


Với mỗi p[i], ta tính số mũ và đem mod cho 10^9 + 6 và dùng lũy thừa nhanh

Ta tính (x1 + 1) * (x2 + 1) * .... * (xk + 1) / (xi + 1)

Ta tạo bảng prefix[i] với ý nghĩa: prefix[i] = (x1+1) * (x2+1) *....* (xi +1) % (10^9 + 6)
tạo suffix[i] = (xk +1) *(xk-1+1) *....* (xi +1) % (10^9 + 6)
Ta tính tích trên khi bị khuyến (xi + 1) = (prefix[i - 1] * suffix[i +1]) % (10^9 + 6)






























