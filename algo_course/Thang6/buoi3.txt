Abstract

cho matrix n*m. mỗi ô chứa bức tượng với chiều cao h[i][j]. 
hỏi có bao nhiêu bước tượng có thể nhìn thấy, khi nhìn cả 4 phía
hình Thang6/Buoi3/img/1.abstract.png minh họa

----
tự phân tích:(duyệt 4 lần, L->R,R->L, U->D, D->U)
- mảng check[i][j] =0.
    FOR i:1->n
        high =0;
        FOR j: 1->m
            nếu h[i][j] > high
                check[i][j] = true
                high = h[i][j]
đếm  xem có bao nhiêu check == true

----------------------

Jumpled graph:

Xét một đô thị G gồm N đinh và các đinh liên thông với nhau.

Xét hàm dfs được tổ chức như sau:
dfs(u)
    đặt v = random các đinh chưa được xét
    dfs(v)

main ():
    dfs(random các đình từ 1 -> N)

hỏi có bao nhiêu đồ thị vô hướng liên thông G có N đỉnh: sao cho hàm DFS chạy ra được mảng p1,p2,p3,...pn

N=3
p=[3,1,2]
ảnh minh họa: 
Thang6/Buoi3/img/2.jumpledGraph.png 
Thang6/Buoi3/img/2.jumpledGraph2.png

Gọi f[1][h] là số lượng đồ thị có thể sinh ra hành trình ứng với i đình đầu tiên và đỉnh thứ i ở độ cao là h

bài toán cơ sở: f[1][0] -1

công thức qhđ:

    khi ta có f[i][h] > 0

    Xét đình thứ i + 1, đinh i + 1 có thể ở những độ cao j' từ 1 -> h + 1

        f[i +1][j'] +=f[i][h] * 2^(j' -1)

Đấp án bài toán: Tính tổng f[n][h] với h: 1 -> n

-----------------------------

Finding RPS

Có N trận đấu bao (P) - búa (R) - kéo (S). Trận đấu thứ i, đối thủ sẽ ra món a[i] (a[i] = 'R', 'S', 'P')
Vì lười, ta sẽ xét k trận liên tục và k trận này ta sẽ ra 1 loại giống nhau. Hỏi số trận thắng tối đa ta có thể đạt được là bao nhiêu nếu k dao động từ 2 -> n. Hãy cho

biet so k lon nhat đe so tran đau chien thang la toi đa

N = 8

RSSPRRPS

k = 4

RRRRSSSS ----- > thang 4 trận

k = 5

Sssssppp ----- > thắng 2 trận 

---------
Gọi countR[i], countS[i], countP[i] là số lượng R, S, P khi xét i phần tử đầu tử đầu tiên.

Khi có 1 đoạn [1 .. r] ==== > số lượng R, S, P lần lượt là: max(countR[r] - countR[1 - 1], countS[r] - countS[1 - 1], countP[r] - countP[1 - 1])

Xét các giá trị k: 2 -> n

[1 .. k], [k+1 .. 2k], [2k+1 .. 3k],
Với giá trị k, ta duyệt các bội j của k (j = k -> n, j += k)
    1 đoạn [j - k + 1 .. j] 
    tìm số lượng nhiều nhất; đó là số lượng trận thắng. tính tổng.
----------------------------------------------------



---------------------------------------------------------

Interactive:

Cho một chuoi s chi gom cac so 0 va 1 va chuoi s nay được an.

Biết chuỗi s có số lượng ký tự là số lẻ

Ta có thể đặt câu hoi, xuat ra 1 chuỗi st cũng gồm các ký tự 0 và 1

Hệ thống sẽ thực hiện như sau:

+ Tính cntCorrect: số lượng vị trí i mà chuỗi st giõng với chuỗi ẩn
+ Tính cntFail : số lượng vị trí i mà chuỗi st khác với chuỗi ẩn

Hệ thống sẽ trà ra 0 nếu cntCorrect > cntFail, ngược lại sẽ trả số 1

Hòi: Hãy tìm ra được chuỗi ẩn sau không quá 1024 lần hỏi

Ví dụ:

S = "0011001"

? 0001011h

==== > 0

-----
Ví dụ:

s = "1011011"

p = "1111111"

Nếu ta thay đổi i ký tự đầu tiên và cho ra được đáp án là 0 và thay đổi i + 1 ký tự đầu tiên lại cho ra đáp án là 1

...--- > chứng tỏ chuỗi được hoán đổi i ký tự đầu tiên là chuỗi có số lượng ký tự đúng là (n + 1) / 2

đặt lo = 0, hi = n - 1

đặt mid = (lo + hi) / 2

flip(mid)

hỏi, nếu trà về số 0 ghi nhận position = mid, lo = mid + 1
else: hi = mid - 1

Vị trí position chính là vị trí mà nếu ta flip tất cả các ký tự từ vị trí 0 -> position, ta được 1 chuỗi có số lượng vị trí đúng = (n + 1) / 2 |
----------------------------------
//ans = 0: wrong<right; ans = 1: wrong > right
ví dụ: 
a=1011011
s=0000000
s=1000000 là là tối thiểu để ans(s) vẫn bằng 0: đúng 3 sai 4

khi đó for &c:s
    c = !c 
    ans(c)=1 thì vị trí đó sai
    ans(c)=0 thì vị trí đó đúng


