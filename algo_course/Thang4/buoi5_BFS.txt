BFS
cho đồ thị {G,E}, xuất phát từ start. độ dài đường đi ngắn nhất đến mọi đỉnh.
1 đường đi ta tính độ dài bằng số cạnh trên đường đi đó

-------------------------
Một đường đi ta sẽ tính độ dài bằng số cạnh trên đường đi đó.
Gọi dist[u] là độ dài của đường đi ngan nhat từ start -> u

Khởi tạo dist[u] = -1

Ta chuẩn bị mot hang đoi queue voi y nghĩa: Luu tru nhung dinh nay trong qua trinh duyet.

lưu start vào hàng đợi dist[start] = 0

Với đinh u trong queue, xet mọi v ke với u
    neu dist[v] == -1
        dist[v] = dist[u] + 1
    đưa v vao queue

Ta xuất các dist[u]
-------------------
khởi tạo cac dist[u] = -1

dist[start] = 0
dua start vao Q

while Q khác rỗng:
    lay u ra khoi Q
    duyệt mọi v kề u:
        neu dist[v] == -1:
        dist[v] = dist[u] + 1
        đưa v vào Q

Độ phức tạp: 0(V + E)

--------------------------------
MOVE:

Cho 2 day so nguyen a va b. Ban dau co mot gia trị S
Ta được phép thực hiện nhiều thao tác như sau:
    Chọn một vị trí i, lay S = (S * a[i] + b[i]) % M
Hoi sau toi thieu bao nhieu phep thì S se tro ve 0 hoac dua ra ket luan la khong the lam.

--------------------------
5 2 1
2 1
3 1

a = [2, 3]
b = [1, 1]

Cho 2 dãy số nguyên a và b gồm N so. Ban đầu có một gia trị S

Ta được phép thực hiện nhiều thao tác như sau:

Chọn một vị trí i, lay S = (S * a[i] + b[i]) % M

Hoi sau toi thieu bao nhieu phep thì S se tro ve 0 hoac dua ra ket luan la khong the lam.

Khởi tạo dist[i] = -1 với mọi i: 0 -> M-1

đưa S vao hàng đợi

dist[S] =0

Lay đinh u ra khỏi hang đợi
duyệt mọi v kề u:
    for i: 1 -> n
        v = (u * a[i] + b[i]) % M
        neu dist[v] == -1:
            dist[v] = dist[u] +1
            đưa v vào hàng đợi.
--------------------------------
Bitmap:

Cho một bảng gồm 2 màu đen và trang. Với mỗi ô (i, j), hãy tìm ô mau đen gần ô nay nhat và tinh khoang cach giữa 2 ô

khoảng cách giữa ô (x1, y1) đến (x2, y2) được định nghĩa bằng khoảng cách Mahathan giữa chúng

khoảng cách Mahathan được tính như sau: |x1 - x2| + |y1 - y2| |

-------------------------
Monster
- giống bài trên.
    - thêm khi loang quái vật đến người không cần đè quái vật lên người vì. người không thể đi qua quái vật đc.
-----------------------
Blue grap

cho cho đồ thị vô hướng n đỉnh, m cạnh 
các node là màu trắng. 
-> task: tô 1 số node thành màu xanh. thỏa mãn q yêu cầu:
    yêu cầu i: khoảng cách ci -> node xanh  gần nhất = di 
    1<q,n<5*10^5; 0<m<5*10^5
n=7 m=8 q=3
u v
1 2
2 3
3 4
4 1
4 5
5 6
6 4
5 7
----
ci di
7 2
4 1
2 1
---------------------------
{ci,di}; sort theo di giảm dần trong pq

đánh dấu các ci là trắng.

while stack!= empty() 
    duyệt vi kề ci
        nếu là trắng. bỏ qua
        nếu chưa tô:
            màu-> trắng
            di ->di-1
            thêm vào stack
-> thêm BFS duyệt từ các ô xanh
    -> tìm đường đi ngắn nhất đến tất cả các node
kiểm tra xem các ci có thỏa mãn không   
