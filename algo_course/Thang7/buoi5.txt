Cây tiền tố (Trie) 

Cho N chuỗi ADN, mỗi chuỗi được tạo nên từ 4 nucleotit: A, C, G, T 

Cho Q truy vấn, mỗi truy vấn có 1 chuỗi ADN, hỏi chuỗi này có xuất hiện trong N chuỗi trên hay không ????? 


N = 6

AACG
GCATT
TTA
AAGT
GCAT
AAGTC


Q = 3 

GCAT  ---> Y 
AT    ---> N 
ACG   ---> N 

Sử dụng set <string> S,  với mỗi truy vấn Q, hỏi chuỗi đó có trong S hay không ??? 

So sánh a < b ====> độ phức tạp để so sánh chuỗi: O(min(|a|, |b|) )

Trie là một cấu trúc dữ liệu nhằm mục đích lưu trữ các chuỗi theo phép so sánh tiền tố với nhau. 


Ta sử dụng con trỏ để lưu trữ các node của trie 

id['A'] = 0;
id['C'] = 1;
id['G'] = 2;
id['T'] = 3;

struct node {
  node *child[4];  
  bool isEnd; 
};

node *createNode() {
  node *ret = new node(); 
  ret->isEnd = false; 
  for (int c = 0; c <= 3; c++) {
    ret->child[c] = NULL;
  }
  return ret; 
}

void addString(const string &s, node *&root) {
  node *p = root; 
  for (int i = 0; i < (int) s.size(); i++) {
    int idChar = id[s[i]]; 
    if (p->child[idChar] == NULL) {
      p->child[idChar] = createNode(); 
    }
    p = p->child[idChar]; 
  }
  p->isEnd = true; 
}

bool check(const string &s, node *root) {
  node *p = root; 
  for (int i = 0; i < (int) s.size(); i++) {
    int idChar = id[s[i]]; 
    if (p->child[idChar] == NULL) {
      return false; 
    }
    p = p->child[idChar]; 
  }
  if (p->isEnd == true) {
    return true; 
  }
  return false; 
} 

main () {
  node *root = createNode(); 

}

------------------------------------------------------------------------------------------------------------------

Search Engine 

Cho N chuỗi, chuỗi thứ i có 1 giá trị sức mạnh là p[i] 

Cho Q truy vấn, mỗi truy vấn gồm một chuỗi st, hỏi trong các chuỗi mà nhận st làm tiền tố, chuỗi nào có sức mạnh lớn nhất ???? 


hackerrank 10
hackerearth 9 

hacker   ====> 10 
hackere  ====> 9 

---------------------------------------------------------------------------------------------------------------------

Word Combination: 

Gọi f[i] là số cách để xây dựng ra chuỗi s gồm i ký tự đầu tiên 

bài toán cơ sở: f[0] = 1 

khi ta có f[i] > 0 

Nếu s[i + 1 .. j] mà có tồn tại trong danh sách từ điển ======> f[j] += f[i] 

đáp án bài toán: f[n]

Ban đầu ta lưu trữ danh sách từ điển vào cây trie 



ababc 


i , j: i + 1 -> n 




i = 2 

j = 3, a 
j = 4, ab 
j = 5, abc
--------------------------------------

Gabby And Addition: 

Định nghĩa phép cộng không nhớ giữa 2 số a và b là phép cộng khi xét từ hàng nhỏ nhất đến hàng lớn nhất, ta lấy tổng 2 số và không nhớ sang hàng lớn hơn. 

Ví dụ: 

145 + 299 = 334

Cho một dãy số a gồm N số nguyên dương a1, a2, ......, aN 

Xét 2 số ai và aj bất kỳ, hỏi tổng ai + aj nhỏ nhất và lớn nhất là bao nhiêu ??????? 


Ví dụ: 

a = [09, 01, 12, 09, 06, 52]

0 64


Nhận xét: Khi số lượng chữ số đã bằng nhau thì khi triển khai phép cộng không nhớ, ta có thể cộng từ trái sang phải. 

for i: 2 -> n 
  for j: 1 -> i - 1 
    Chọn ra a[i] + a[j] nhỏ nhất và lớn nhất 

---------------------------------------------------------------------------------------------------------------------------------

SPC1 (Spring Contest 2022) 

Cho một tập hợp S là tập hợp rỗng {}

Có Q thao tác, mỗi thao tác như sau: 

1. Thêm một số x vào tập S 
2. Nếu ta sắp xếp các số trong tập S không giảm, hỏi số nhỏ thứ K là số nào ??????? 


thêm số 92 =====> 0000000092





0145
 
0163

k = 1 

------------------------------------------------------------------------------------------------------------------------------

Type printer (IOI 2008) 

tiktok      
algorithm    
algorithn
algoritho     
algo        
titi        
leetcode    
leet       


leetPcodeP--------algoPrithmP-nP---------titiP--ktokP




lastString = "algorithm" 

dfs(node *p, int &pos) {
    for (ch: 'a' : 'z') {
        nếu ch != lastString[pos] {
            dfs(p->child[ch], pos) 
        }
    }
    dfs(p->child[lastString[pos]], pos + 1) 
}

---------------------------------------------------------------------------------------------------------------------------------






















