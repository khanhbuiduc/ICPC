fenwick tree

khi bài toán:
    query 1: tăng f[x] lên k đơn vị.
    query 2: tính sum(f[1->i]);
fenwick:
    void update(index, k)
        for(;index<=100'000; index += index & -index)
            fw[index] += k;
    
    ll get(int index){
        ll res = 0;
        for(;index<=100'000; index -= index & -index)
            res+=fw[index];
        return res;
    }
----
nkinv:

đề bài: cho một hoán vị n số nguyên dương trong đoạn [1..n]

hãy đếm xem có bao nhiêu cặp nghịch thế.

cặp nghịch thế: i<j thì p[i]>p[j];

ví dụ:

N==5

[2,5,1,4,3]

===> có 5 cặp nghịch thế.
---------------------------------------------------
dùng segment tree.
xét từ n-1 -> 0;

0+1+0+3+1 = 5

f[1,0,1,1,1]

khi ta duyệt i: n-1 -> 0 
    ta quan tâm sum[a[i] - 1]; 
    => cập nhập f[ai] lên 1
=> segment tree: node lưu tổng.
----------------------
quay về bài toán.

for(i,n,1){
    ans += get(a[i] - 1)// tính tổng 1->a[i]
    update(a[i],1)
}

-------------------------------------------------------

inversion:

cho hoán vị N phần tử. chọn a[i]. 
    dồn số nhỏ hơn a[i] về bên trái
    dồn số lớn hơn a[i] về phía bên phải.
=> chọn a[i] để số lượng nghịch thế min.

a = {4,1,5,3,2,6}

chọn a[1]: 
    a=[1,3,2,4,5,6] ===> 1
chọn a[2]
    a=[1,2,3,4,5,6] ===> 0

-----
cách tự nghĩ:
    - chọn từng số rồi đếm số nghịch thế.
    - O(n^2 log(n))
-------------
cách chọn nào là tối ưu nhất:
    -  khi chọn nghịch thế sẽ bị chia ra làm 2 phần: 
        1->i-1 và i -> n;
ta dùng 2 bẳng bigger và smaller.

chọn 4: 1,3,2   4   6,5

smaller[x]: số lượng số bên phải < x
    => dùng fenwick.
bigger[x]: số lượng số bên trái > x;
    duyệt i: 1->n
        x = a[i]
        bigger[x] = i - 1 - (x -1- smaller[x])

Chọn số k làm mốc ===== > số cặp nghịch thế: 

Ta tạo bang 
Left[i] = smaller[1..i]
Right[i] = bigger[i..n]

====== > khi chọn k làm mốc ====== > Left[k - 1] + Right[k + 1]


-----------------------------------------------------------

Nkmobiles (IOI 2001)

Cho một bảng kích thước 1024 x 1024

Có 3 loại truy vấn:

Truy vấn 1: Xét (x, y) và  tăng f[x][y] lên k đơn vị

Truy vấn 2: Xét một hình chữ nhật với góc trái trên (x1, y1) và góc phải dưới là (x2, y2), tính tổng các số trên hình chữ nhật đó

Truy vấn 3: Dừng thuật toán

-----
fenwick 2 chiều.

Nếu ta có thể thiết kế hàm sum(x, y) với ý nghĩa: sum(x, y) là tổng các số trên hình chữ nhật từ (1, 1) -> (x, y)

==== > để tính tổng các số trên hình chữ nhật (x1, y1) -> (x2, y2):

sum(x2, y2)-sum(x2,y1-1)-sum(x1-1,y2)+sum(x1-1,y1-1)

Cây fenwick 2D

Cập nhật giá trị tại vị trí (x, y) lên k đơn vị

void update(int x, int y, int k) {
    for (indexx = x; indexx <= 1024; indexx += indexx & -indexx)
    for (indexy = y; indexy <= 1024; indexy += indexy & -indexy)
        fw[indexx][indexy] += k;

}

int get(int x, int y) {
    int ret = 0;
    for (indexx = x; indexx > 0; indexx -= indexx & -indexx)
    for (indexy = y; indexy > 0; indexy -= indexy & -indexy) 
        ret += fw[indexx][indexy];
    return res
}

---tính sum chính là get là xong.

----------------------------------

Sort problems (ICPC mien Trung năm 2021)

có N học sinh, bạn thứ i có điểm {a[i], b[i]}

Biết a[1..n]: distinct, b[1..n]: distinct
a[i], b[j] nằm trong đoạn [1..n]


student i áp đảo j nếu: a[i] > a[j] và b[i] > b[j]

đếm số cách chọn k học sinh: k có học sinh nào không áp đảo nhau.

N = 6, k=3

2 5
6 3
4 1
3 6
1 4
5 2
---
sort sẽ có gì đó.
1 4
2 5
3 6
4 1
5 2
6 3

-------
qhd:
Sử dụng quy hoạch động:

Gọi f[i][j] là số cách để chọn ra j bạn có điểm văn tăng dần khi ta xét i bạn đầu tiên và bạn thứ i là bạn CUỐI CÙNG trong cách chọn

bài toán cơ sở: f[0][0] =1

đáp án bài toán: Tổng của các f[i][k] với i: 1 -> n

công thức qhđ:

    f[i][j] = ???

Giả sử trước đó ta có một bạn x sao cho b[x] < b[i] :

    f[i][j] = Tổng (f[x][j - 1]) với x < i và b[x] < b[i]

O(n^2 * k); 

---
tối ưu: 

Xét k + 1 cây fenwick, mỗi cây fenwick tương ứng:

Cây fenwick thứ j sẽ có giá trị là fw[i][j] với i là gia trị của điểm văn khi xét bai toan chọn j bạn, fw[i][j] la tổng số cach khi xet cac điểm văn từ 1 -> i

khi xét trên bài toán chọn j bạn

f[i][j] = Tổng các fw[1][j - 1] + fw[2][j - 1] + ...........+ fw[b[i] - 1][j - 1]

update(b[i], j - 1, f[i][j - 1])

    for j: 1 -> k
    for i: 1 -> n
        f[i][j] = get(b[i] - 1, j - 1)
        update(b[i], j - 1, f[i][j - 1])

-------------------------

Manhathan Distance:

Cho N điểm trên mặt phẳng, điểm thứ i có tọa độ là (xi, yi)

Khoảng cách Manhathan giữa điểm i và điểm j = |xi - xj| + |yi - yj|

Giả sử ta sắp xếp các khoảng cách Manhathan tăng dần, hãy cho biết khoảng cách Manhathan thứ k là bao nhiêu ?????

dis<400'000'000
khoảng cách càng lớn càng nhiều cặp thỏa mãn.
BS: mid = D. khoảng cách có bao nhiêu cặp d[i,j] <= D;
    số cặp > k: dịch phải
    số cặp < k: dịch trái. lưu đáp án.

d(i, j) = |xi - xj| + lyi - yjl

= xi - xj + yi - yj

hoặc

= xi - xj + yj - yi

hoặc

= xj - xi + yi - yj

hoặc

= xj - xi + yj - yi

= max(xi - xj + yi - yj , xi - xj + yj - yi, xj - xi + yi - yj, xj - xi + yj - yi)

= xj - xi + yj - yi

= max(xi - xj + yi - yj , xi - xj + yj - yi, xj - xi + yi - yj, xj - xi + yj - yi )

= max(xi + yi - (xj + yj) , xi - yi - (xj - yj), -(xi - yi) + xj - yj ,

Đặt a[i] = x[i] + y[i], b[i] = x[i] - y[i]

= max(a[i] - a[j], b[i] - b[j], a[j] - a[i],

-(xi + yi) + xj + yj )

b[j] - b[i])


Nếu ta sắp xếp các điểm tăng dần theo a[i]

j < i thì a[j] <= a[i]

với j < i, ta có khoảng cách Manhathan giữa (i, j)

= max(a[i] - a[j], b[i] - b[j],

Bài toán đưa về: Đếm có bao nhiêu cặp điểm (i, j) sao cho j < i và max(a[i] - a[j], b[i] - b[j],

Giả sử ta cố định điểm thứ i

Do a[i] đã tăng dan, ta có thể xác định được điểm j xa i nhat về phía ben trai sao cho a[i] - a[j] <= k

b[j] - b[i])

b[i] - b[j] <= k <= > b[j] > b[i] - k

b[j] - b[i] <= k <= > b[j] <= b[i] + k

Những j thỏa mãn b[i] - b[j] <= k và b[j] - b[i] <= k là những j sao cho b[j] thuộc đoạn [b[i] - k .. b[i] + k]

i = 10, 1 = 3

(3, 10), (4, 10), (5, 10), (6, 10), .... , (9, 10)

Giả sử với i, ta xác định 1 là vị trí xa i nhất về phía bên trái sao cho a[i] - a[l] <= k

1 = 1 |

Duyệt i: 1 -> n
    update(b[i], 1)
    while 1 < i && a[i] - a[1] > k:
    update(b[1], -1)
    1++
    đặt low = b[i] - k, high = b[i] + k
    đếm có bao nhiêu giá trị b[i] nằm trong đoạn [low .. high] ==== > get(high) - get(low - 1)

Ta gọi một cây fenwick với ý nghĩa:

fw[i] là số lượng điểm j thỏa mãn có giá trị b[j] = i