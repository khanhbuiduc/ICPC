Joints And Bridges:

Cho một đồ thị vô hướng gồm N đinh, M cạnh. Hãy đếm có bao nhiêu cầu và bao nhiêu khớp

Trong đo cầu la một cạnh sao cho khi xoa cạnh nay, đo thị se tach thanh nhieu thanh phan liên thông hơn

Khớp là một đinh sao cho khi xoa đinh nay, đo thị được tach thanh nhieu thanh phần liên thông hơn.

Cây Dfs:

Là mot cay the hien viec duyet qua cac canh theo thuat toan Dfs

Thuật toán tìm cầu:
    Ta gọi 2 bảng numb và low với ý nghĩa:
        - numb [u] là thứ tự duyệt dfs khi ta đứng tại u
        - low[u] là thứ tự numb nhỏ nhat có thể mà ta có thể gặp lại
    
timeDfs = 0
dfs(u, father)
    timeDfs ++
    numb[u] = low[u] = timeDfs
    duyệt mọi đỉnh v kề với u
        nếu v == father
            continue
        nếu numb[v] > 0:
            low[u] = min(low[u], numb[v])
        else:
            dfs(v, u)
            low[u] =min(low[u], low[v])
            neu numb[v] == low[v]:
            đưa cạnh u - v vao danh sach cầu.
-----
Tìm khớp

Nhận xét: u là khớp nếu tồn tại một đinh con v sao cho low[v] >= num[u]

Ta tạo bảng isJoint[u] = true / false với ý nghĩa u có phải là khớp hay không ?
timeDfs = 0
dfs(u, father)
    timeDfs ++
    numb[u] = low[u] = timeDfs
    children = 0
    duyệt mọi đỉnh v kề với u
        neu v == father
            continue
        nếu numb[v] > 0:
            low[u] = min(low[u], numb[v])
        else:
            dfs(v, u)
            children++
            low[u] = min(low[u], low[v])
            neu u == 1 va children >= 2:
                isJoint[u] = true
            else nếu u != 1:
                nếu low[v] >= numb[u]:
                isJoint[u] = true
----------
main ():
    dfs(1, -1)
    duyệt mọi u: 1 -> n
        nếu isJoint[u] == t|
------------------------------------------------------

cho 1 cây
có M lần đi sửa cầu, đi sửa lần lượt các cạnh từ u->v
sau khi sửa m lần, còn bao nhiêu cạnh chưa được sửa 

-----------------------------------------------------
sửa cạnh x đến y; tạo cạnh x->y; đếm xem có bao nhiêu cầu
--------
ở testcase 7: có cạnh 1->10,cạnh 1-10 đã sửa; thì 1-10 vẫn là cầu

-> tạo unorder_map {{u,v},t}; cạnh u,v đã đc sửa -> không tính cạnh {u,v} là cầu
--------------------------------------------------------
weather

n đỉnh, m cạnh

đếm cạnh: xét A->B đếm có bao nhiêu cạnh xóa đi mà k thể đi từ A->B

tính tổng cạnh khi xét tất cả cặp đỉnh

--------------
nhận xét: những cạnh phải xóa là cầu
thay đổi bài toán
    bài toán gốc: xét mọi cạnh {u,v} đếm có bao nhiêu cầu, sau đó tính tổng số cầu
    bài toán mới:xét mỗi cầu: đếm số cặp đỉnh k tới đc với nhau khi xóa cầu. sau đó tính tổng

gọi size[u] là số lượng đỉnh trên cây có gốc là u 
-------------------------------------------------------------
Dumbell:

Ta định nghĩa "đô thị hình quả tạ" là một đồ thị cấu trúc như sau:

Là mot đo thị vo huong, gom 1 thanh chan ngang va 2 phan duoc noi bang thanh nay la 2 do thi đay đủ.

Cho một đô thị ban đầu gồm N đinh, M canh. Ta cần tạo ra đo thị hình qua ta bang cach them mot so canh vao. Hỏi so canh ít nhat cần thêm vào là bao nhiêu ?????? 

--------------------------

nhận xét: cấu trúc hình quả tạ:
    bên trái: n đỉnh - bên phải có x-n đỉnh
1 đồ thị đầy đủ x đỉnh: left= x(x-1)/2 cạnh
..............n-x.....: right = (x-n)(x-n-1)/2
thanh ngang: 1

tổng cạnh: x(x-1)/2 + (x-n)(x-n-1)/2 + 1

tổng số cạnh cần bổ sung: x(x-1)/2 + (x-n)(x-n-1)/2 + 1 - M
--------------------------------------------------------------------------------
Gọi f[i][j][state] có thể hay không thể chọn 1 đồ thị:
    - chọn i thành phần liên thông.
    - chọn j = x
    - state = 0; không sử dụng cầu làm thanh quả ta. state = 1; sử dụng cầu làm thanh quả ta.

BTCS: f[0][0][0] = 0;

xét thành phần liên thông i+1:

không chấp nhận tplt i+1: vào trong vùng có j đỉnh
    f[i+1][j][state] = true
chấp nhận tplt i+1: vào trong vùng có j đỉnh
    f[i+1][j + size[i+1]][state] = true;
nếu state == 1 && v[i+1]!= rỗng
    nếu ta chọn số lượng đỉnh sau khi tách tplt thứ i+1 là v[i+1][k]
    f[i+1][j+ v[i+1][k]] [1] = true;

đáp án bài toán:
    x đc tạo nếu f[nComponents][x][0] == true || f[nComponents][x][1]==true
----------------------------------------
gọi f[i][state] là tập hợp những giá trị x khi chọn và k chọn một vài tp liên thông ban đầu và trạng thái state 

state = 0: ta chưa chọn bat kỳ cạnh nao làm thanh qua tạ
state = 1: ta đa chon 1 canh nao do lam thanh qua ta roi.

ta lưu f[i][state] như là các bitset, mỗi bitset gồm 100000 bit.

bài toán cơ sở: f[0][0].set(0, 1)

công thức qhđ:

với f[i][state], xét thanh phần liên thông thứ i+1

1. ta không ket nạp cac đinh trong tplt thứ i+1 vao trong cac trang thai ma f[i][state] đang luu: f[i+1][state] |= f[i][state]
2. ta kết nạp các đinh trong tplt thứ i+1 vào trong cac trạng thai ma f[i][state] đang luu: f[i+1][state] |= f[i][state] << sz[i+1]
3. nếu state == 0 và v[i+1] != rỗng, nếu chọn v[i+1][k] làm số lượng đinh kết nạp: f[i+1][1] |= f[i][state] << v[i+1][k]
đap an bai toan: Tap hop cac x thoa man la f[nComponent][0] | f[nComponent][1]

Một thao tác xử lý trong bit có độ phức tạp là 0(V/64) với V là số lượng bit

Số thao tác: 100000 * 100000 / 64
-----------------------------------
